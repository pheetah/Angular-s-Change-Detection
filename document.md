# Angular's Change Detection
*A document aiming to explain Angular's change detection, Ey√ºp Fatih Ersoy, 24/06/2021*

In general, we don't really want to change Angular's change detection behaviour as Angular does everything for us automatically. But, there are some conditions we need to put some strategy on detecting changes especially when:
 - There are a lot of bindings in the component.
 - There are too many async operations which trigger Angular's change detection cycles too often.

## Bindings
When a component is created, Angular creates a view definition to the component. For example assume we have a component as **_Component A_** and we define a simple ***span*** element like this;

```ruby
<span>I am {{name}}</span>
```
Angular turns this out;
```ruby
function View_AComponent_0(l) {
    return jit_viewDef1(0,
        [
          jit_elementDef2(0,null,null,1,'span',...),
          jit_textDef3(null,['I am ',...])
        ], 
        null,
        function(_ck,_v) {
            var _co = _v.component;
            var currVal_0 = _co.name;
            _ck(_v,1,0,currVal_0);
```

*Which is referred in [this article](https://indepth.dev/posts/1129/the-mechanics-of-dom-updates-in-angular).*

This separates view elements and bindings for Angular. View elements are stored in an array as it seems;
```ruby
...
    return jit_viewDef1(0,
        [
          jit_elementDef2(0,null,null,1,'span',...),
          jit_textDef3(null,['I am ',...])
        ],
...
```
And bindings are handled in ***updateRenderer*** function inside the viewdefinition generated by Angular:
```ruby
...
        function(_ck,_v) {
            var _co = _v.component;
            var currVal_0 = _co.name;
            _ck(_v,1,0,currVal_0);
...
```
***updateRenderer*** function is executed everytime Angular cycles a change detection on the component. That's one of the reasons which can make heavy detection cycles and make the application slower, if there are too many binding on the current component, this means more parameters to the updateRenderer function, and causes as heavier detection cycles.

## What Triggers Change Detection
Angular, supports change detection for low-level APIs, as follows:
- All browser events (click, mouseover, keyup, etc.)
- setTimeout() and setInterval()
- Ajax HTTP requests

While doing that, Angular uses **zones** to trigger change detection, using **zone.js** library which patches low-level browser APIs for Angular. As an [example](https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/), let's look at how Angular ***overrides*** one of low-level browser APIs: **addEventListener**. 
```ruby
function addEventListener(eventName, callback) {
     // call the real addEventListener
     callRealAddEventListener(eventName, function() {
        // first call the original callback
        callback(...);     
        // and then run Angular-specific functionality
        var changed = angular.runChangeDetection();
         if (changed) {
             angular.reRenderUIPart();
         }
     });
}
```
This is the new version of **addEventListener** created by Angular. As we can see, Angular changed **addEventListener**, added new functionalities to it, and one of these functionalities is the change detection mechanism.

```ruby
...
        var changed = angular.runChangeDetection();
         if (changed) {
             angular.reRenderUIPart();
         }
....
```

## More On Change Detection
As a  **view** is higher definition of dom elements created by Angular, a view comes with [4 important state](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/types.ts#L325), which are:
```
FirstCheck = 1 << 0,
ChecksEnabled = 1 << 1,
Errored = 1 << 2,
Destroyed = 1 << 3
```
By default change detection strategy, Angular components are generated as **ChecksEnabled as true**, but developer may specify **ChecksEnabled as false**. Angular covers this behaviour in an higher order functionality which is **OnPush** strategy.


> By default, Angular Change Detection works by checking if the value of template expressions have changed. This is done for all components.


This means, Angular doesn't deep dive to detect changes on objects in components whose view state is **OnPush**. In these components, change is detectable, when the **reference** of object changes. This can be achieved creating a new object with new values, and assigning object to the new object, and this behaviour can be supported by the use of ```const ``` and ```readonly``` keywords which provides us to create immutable datas. Since these are about to make the objects ***immutable***, there are also supported APIs to change the mutable object in the immutable way, by this way, Angular can detect changes. These are available for the data structures like [arrays and objects](https://ultimatecourses.com/blog/all-about-immutable-arrays-and-objects-in-javascript), the most used data structures of Javascript. For example ***spread operator ( {... object} )***, ***array.slice()*** are two of the most famous ones.

To understand the idea better, [check this little project](https://stackblitz.com/edit/changedtc?file=src%2Fapp%2Fapp.component.html).

## Change Detection Strategies
- ***Default Strategy*** :

By default strategy, Angular does ***dirty checking***, which means any time change detection is triggered, Angular checks component with all of its childs. This is decorated in Angular like this: 

```ruby
@Component({
...
 changeDetection:  ChangeDetectionStrategy.Default
})
```
Even if not specified, Angular uses this change detection strategy, which makes in low-level **ChecksEnabled = true** in [ViewState](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/types.ts#L325).

![default](https://user-images.githubusercontent.com/77587142/123429229-62f37100-d5cf-11eb-96eb-307693011885.gif)

- ***OnPush Strategy***

When we set our component's change detection strategy as ***OnPush Strategy***, in low-level Angular does set **ChecksEnabled = false** in [ViewState](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/types.ts#L325). We decorate it using Angular's component decorators like this:
```ruby
@Component({
...
 changeDetection:  ChangeDetectionStrategy.OnPush
})
```


This strategy ensures that, the component which has the strategy Onpush, won't be changed unless:
- @Input property changes (importance of immutability)
- the component or one of its children triggers an event handler
- change detection is triggered manually (importance of ChangeDetectorRef)
- an observable linked to the template via the async pipe emits a new value (importance of async pipes)

![cd-on-push-cycle](https://user-images.githubusercontent.com/77587142/123429147-49522980-d5cf-11eb-82d5-221aed55ca4b.gif)

We have discussed about immutability and event handlers. To continue, ***ChangeDetectorRef*** is needed to be explained. When a component's view is created, this view is associated with a token named ***ChangeDetectorRef***. This token allows us to handle our change detection manually.

```ruby
export declare abstract class ChangeDetectorRef {
    abstract checkNoChanges(): void;
    abstract detach(): void;
    abstract detectChanges(): void;
    abstract markForCheck(): void;
    abstract reattach(): void;
}
export abstract class ViewRef extends ChangeDetectorRef {
   ...
}
```

ChangeDetector has 5 useful functions. From Angular's documentation:
> - markForCheck() : When a view uses the OnPush (checkOnce) change detection strategy, explicitly marks the view as changed so that it can be checked again. 
> This means change detection won't be triggered, but when the next change detection cycle runs, the properties will change.
> - detach(): Detaches this view from the change-detection tree. A detached view is not checked until it is reattached.
> - reattach(): Re-attaches the previously detached view to the change detection tree. Views are attached to the tree by default.
> - checkNoChanges(): Checks the change detector and its children, and throws if any changes are detected.
> - detectChanges(): Checks this view and its children. This happens for the component and its children regardless of their change detection strategy.

![changedetectorref](https://user-images.githubusercontent.com/77587142/123428686-bca76b80-d5ce-11eb-8d77-b3e966cf63fe.png)

OnPush stregy ignores to cycle change detection under these conditions:
- setTimeout() and setInterval()
- Promise.resolve().then(), (of course, the same for Promise.reject().then())
- rxjs subscriptions, which also includes ajax HTTP call subscriptions.

And this is where ***async pipe*** becomes important. [In the source code](https://github.com/angular/angular/blob/5.2.10/packages/common/src/pipes/async_pipe.ts#L139), we see async pipe has ***markForCheck()*** function of ***ChangeDetectorRef*** inside:

```ruby
  private _updateLatestValue(async: any, value: Object): void {
    if (async === this._obj) {
      this._latestValue = value;
      this._ref.markForCheck();
    }
```

which makes async pipe to update the properties on the next cycle, on rxjs subscriptions even though component uses ***OnPush*** strategy.


examples: [example1](https://stackblitz.com/edit/angular-ivy-gbvjnm?file=src%2Fapp%2Fapp.component.ts)
