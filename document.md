# Angular's Change Detection
*A document aiming to explain Angular's change detection, Ey√ºp Fatih Ersoy, 24/06/2021*

In general, we don't really want to change Angular's change detection behaviour as Angular does everything for us automatically. But, there are some conditions we need to put some strategy on detecting changes especially when:
 - There are a lot of bindings in the component.
 - There are too many async operations which trigger Angular's change detection cycles too often.

## Bindings
When a component is created, Angular creates a view definition to the component. For example assume we have a component as **_Component A_** and we define a simple ***span*** element like this;

```ruby
<span>I am {{name}}</span>
```
Angular turns this out;
```ruby
function View_AComponent_0(l) {
    return jit_viewDef1(0,
        [
          jit_elementDef2(0,null,null,1,'span',...),
          jit_textDef3(null,['I am ',...])
        ], 
        null,
        function(_ck,_v) {
            var _co = _v.component;
            var currVal_0 = _co.name;
            _ck(_v,1,0,currVal_0);
```

*Which is referred in [this article](https://indepth.dev/posts/1129/the-mechanics-of-dom-updates-in-angular).*

This separates view elements and bindings for Angular. View elements are stored in an array as it seems;
```ruby
...
    return jit_viewDef1(0,
        [
          jit_elementDef2(0,null,null,1,'span',...),
          jit_textDef3(null,['I am ',...])
        ],
...
```
And bindings are handled in ***updateRenderer*** function inside the viewdefinition generated by Angular:
```ruby
...
        function(_ck,_v) {
            var _co = _v.component;
            var currVal_0 = _co.name;
            _ck(_v,1,0,currVal_0);
...
```
***updateRenderer*** function is executed everytime Angular cycles a change detection on the component. That's one of the reasons which can make heavy detection cycles and make the application slower, if there are too many binding on the current component, this means more parameters to the updateRenderer function, and causes as heavier detection cycles.

## What Triggers Change Detection
Angular, supports change detection for low-level APIs, as follows:
- All browser events (click, mouseover, keyup, etc.)
- setTimeout() and setInterval()
- Ajax HTTP requests

While doing that, Angular uses **zones** to trigger change detection, using **zone.js** library which patches low-level browser APIs for Angular. As an [example](https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/), let's look at how Angular ***overrides*** one of low-level browser APIs: **addEventListener**. 
```ruby
function addEventListener(eventName, callback) {
     // call the real addEventListener
     callRealAddEventListener(eventName, function() {
        // first call the original callback
        callback(...);     
        // and then run Angular-specific functionality
        var changed = angular.runChangeDetection();
         if (changed) {
             angular.reRenderUIPart();
         }
     });
}
```
This is the new version of **addEventListener** created by Angular. As we can see, Angular changed **addEventListener**, added new functionalities to it, and one of these functionalities is the change detection mechanism.

```ruby
...
        var changed = angular.runChangeDetection();
         if (changed) {
             angular.reRenderUIPart();
         }
....
```

## More On Change Detection
As a  **view** is higher definition of dom elements created by Angular, a view comes with [4 important state](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/types.ts#L325), which are:
```
FirstCheck = 1 << 0,
ChecksEnabled = 1 << 1,
Errored = 1 << 2,
Destroyed = 1 << 3
```
By default change detection strategy, Angular components are generated as **ChecksEnabled as true**, but developer may specify **ChecksEnabled as false**. Angular covers this behaviour in an higher order functionality which is **OnPush** strategy.


> By default, Angular Change Detection works by checking if the value of template expressions have changed. This is done for all components.


This means, Angular doesn't deep dives to detect changes on objects. In Angular, change is detectable, when the **reference** of object changes. This can be achieved creating a new object with new values, and assigning object to the new object, and this behaviour can be supported by the use of ```const ``` and ```readonly```. These are about to make the objects ***immutable***. There are also supported APIs to change the mutable object in the immutable way, by this way, Angular can detect changes. These are available for the data structures like [arrays and objects](https://ultimatecourses.com/blog/all-about-immutable-arrays-and-objects-in-javascript), the most used data structures of Javascript. For example ***spread operator ( {... object} )***, ***array.slice()*** are two of the most famous ones.

