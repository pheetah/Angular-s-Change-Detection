# Angular's Change Detection
*A document aiming to explain Angular's change detection*

In general, we don't really want to change Angular's change detection behaviour as Angular does everything for us automatically. But, there are some conditions we need to put some strategy on detecting changes especially when:
 - There are a lot of bindings in the component.
 - There are too many async operations which trigger Angular's change detection cycles too often.

## Bindings
When a component is created, Angular creates a view definition to the component. For example assume we have a component as **_Component A_** and we define a simple ***span*** element like this;

```
<span>I am {{name}}</span>
```
Angular turns this out;

```
function View_AComponent_0(l) {
    return jit_viewDef1(0,
        [
          jit_elementDef2(0,null,null,1,'span',...),
          jit_textDef3(null,['I am ',...])
        ], 
        null,
        function(_ck,_v) {
            var _co = _v.component;
            var currVal_0 = _co.name;
            _ck(_v,1,0,currVal_0);
```

*Which is referred in [this article](https://indepth.dev/posts/1129/the-mechanics-of-dom-updates-in-angular).*

This separates view elements and bindings for Angular. View elements are stored in an array as it seems;
```
...
    return jit_viewDef1(0,
        [
          jit_elementDef2(0,null,null,1,'span',...),
          jit_textDef3(null,['I am ',...])
        ],
...
```
And bindings are handled in ***updateRenderer*** function inside the viewdefinition generated by Angular:
```
...
        function(_ck,_v) {
            var _co = _v.component;
            var currVal_0 = _co.name;
            _ck(_v,1,0,currVal_0);
...
```
***updateRenderer*** function is executed everytime Angular cycles a change detection on the component. That's one of the reasons which can make heavy detection cycles and make the application slower, if there are too many binding on the current component, this means more parameters to the updateRenderer function, and causes as heavier detection cycles.

## What Triggers Change Detection
Angular, supports change detection for low-level APIs, as follows:
- All browser events (click, mouseover, keyup, etc.)
- setTimeout() and setInterval()
- Ajax HTTP requests

While doing that, Angular uses **zones** to trigger change detection, using **zone.js** library which patches low-level browser APIs for Angular. As an [example](https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/), let's look at how Angular ***overrides*** one of low-level browser APIs: **addEventListener**. 
```
function addEventListener(eventName, callback) {
     // call the real addEventListener
     callRealAddEventListener(eventName, function() {
        // first call the original callback
        callback(...);     
        // and then run Angular-specific functionality
        var changed = angular.runChangeDetection();
         if (changed) {
             angular.reRenderUIPart();
         }
     });
}
```
This is the new version of **addEventListener** created by Angular.
